<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <title>SPC-1000 Samsung Electronics 8bit personal computer</title>
        <style>
            body {
                background-color: #ffffff;
            }
            #keyboardCanvas {
                border: 1px solid #999;
                box-shadow: 0 0 10px rgba(0,0,0,0.1);
            }
            .img-concert {
                width: 240px;
                height: 180px;
            }
        </style>
    </head>
    <body>
        <table align="center" padding="0">
            <tr><td valign="bottom"><img src="images/samsung_logo.png"></td><td style="font-family: 'Trebuchet MS'; font-size: 2.6rem; text-shadow: 4px 4px 5px gray; line-height: 1.2">&nbsp;SPC-1000&nbsp;<a href="https://github.com/retro-1000/retro-1000.github.io/issues">ê°œì„ ìš”ì²­</a></td><td><img src="images/spc-1000.jpg"></td></tr>
        </table>
        <div align="center"><span id='controls'><input type="button" value="ğŸ–­ ë¡œë”© SHIFT+F1" onclick="LOAD();"> <input type="button" value="&#x1F3C3; RUN" onclick="RUN();"> <input type="button" value="ì´ì „ ğŸ–­ ALT + â‡¦" onclick="tape_prev();"> <input type="button" value="ë‹¤ìŒ ğŸ–­ ALT + â‡¨" onclick="tape_next();"> <input type="button" value="ë¦¬ì…‹ &#x27f3;" onclick="RESET(1);"> <input type="button" value="ì „ì²´í™”ë©´ &#x26F6;" onclick="Module['canvas'].requestFullscreen()"></span></div>
        <div align="center">
            <drop_zone><canvas id="canvas" oncontextmenu="event.preventDefault()" allow="autoplay"></canvas></drop_zone>
        </div>
        <div align="center">
            <span>
                <table align="center" padding="0">
                    <tr valign="top"><td>
                <label className="input-file-button" for="upload" style="padding: 1px 5px;background-color:gray;border-radius: 3px;color: white;cursor: pointer;">
                    &#x1f5ce; ì—…ë¡œë“œ
                  </label>
                  <input type="file" id="upload" accept=".tap, .cas" data-buttonText="íŒŒì¼" style='display:none' /></td>
                  <td><a href="http://hits.dwyl.com/spc-1000/spc-1000githubio" target="_blank">
                    <img src="https://hits.dwyl.com/spc-1000/spc-1000githubio.svg?style=flat&show=unique"></a></td>
                  <td><button id="screenshot" type="button"> &#x2399; í™”ë©´ìº¡ì²˜</button></td>
                  <td><input type="button" id="showkeyboard" value="ê°€ìƒí‚¤ë³´ë“œ" style="display:none" onclick="toggle_keyboard();"/></td>
                  </tr></table>
            </span>
        </div>    
        <div align="center">
            <canvas id="keyboardCanvas" oncontextmenu="event.preventDefault()"></canvas></div>
        </div>
        <div align="center">íœ´ëŒ€í°ì´ë‚˜ íƒ€ë¸”ë¦¿ì€ ê°€ìƒí‚¤ë³´ë“œê°€ ìë™ìœ¼ë¡œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.<br/> ì•„ë˜ ê²Œì„ ìŠ¤ìƒ·ì„ í´ë¦­í•˜ë©´ í…Œìë¡œë”©ì´ ì‹œì‘ë˜ê³  ê²Œì„ì´ ìë™ìœ¼ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.</div> 
        <div align="center"><a href="javascript:tape_loading('lode_runner1-mayhouse.tap');"><img class="img-concert" src="images/spc-1000_240720_0.png" /></a>
            <a href="javascript:tape_loading('ASTEROID%20BELT.tap','F6');"><img class="img-concert" src="images/spc-1000_240720_1.png" /></a>
            <a href="javascript:tape_loading('Xevious.cas');"><img class="img-concert" src="images/spc-1000_240720_2.png" /></a>
        </div>     
        <script type='text/javascript'>
            var Module = {
                canvas: (function() { return document.getElementById('canvas'); })()
            };
            function getCanvasBlob(canvas) {
                return new Promise(function(resolve, reject) {
                    canvas.toBlob(function(blob) {
                        resolve(blob)
                    })
                })
            }
            const elem1 = document.querySelector('#screenshot');
            var screen_num = 0;
            var tapename = null;
            elem1.addEventListener('click', () => {
                var canvasblob = getCanvasBlob(canvas);
                canvasblob.then(function(blob) {
                    var date = new Date().format('yyMMdd');
                    if (tapename != null)
                        if (screen_num > 0)
                            screenshotfile = `${tapename}_${screen_num}.png` 
                        else
                            screenshotfile = `${tapename}.png`
                    else
                        screenshotfile =  `spc-1000_${date}_${screen_num}.png`
                    console.log(tapename);
                    saveBlob(blob, screenshotfile);
                    screen_num += 1;
                }, function(err) {
                    console.log(err)
                });
            });
            const saveBlob = (function() {
              const a = document.createElement('a');
              document.body.appendChild(a);
              a.style.display = 'none';
              return function saveData(blob, fileName) {
                 const url = window.URL.createObjectURL(blob);
                 a.href = url;
                 a.download = fileName;
                 a.click();
              };
            }());
            var reset_required = false;
            const input = document.querySelector("#upload");
            input.addEventListener('change', upload_file);
            const supportsFileSystemAccessAPI =
            "getAsFileSystemHandle" in DataTransferItem.prototype;
          const supportsWebkitGetAsEntry =
            "webkitGetAsEntry" in DataTransferItem.prototype;            
            // This is the drag and drop zone.
            const elem = document.querySelector('drop_zone');

            // Prevent navigation.
            elem.addEventListener('dragover', (e) => {
            e.preventDefault();
            });

            // Visually highlight the drop zone.
            elem.addEventListener('dragenter', (e) => {
            elem.style.outline = 'solid red 10px';
            });

            // Visually unhighlight the drop zone.
            elem.addEventListener('dragleave', (e) => {
            elem.style.outline = '';
            });

            // This is where the drop is handled.
            elem.addEventListener('drop', async (e) => {
            // Prevent navigation.
            e.preventDefault();
            // Unhighlight the drop zone.
            elem.style.outline = '';
            // Prepare an array of promisesâ€¦
            const fileHandlesPromises = [...e.dataTransfer.items]
                // â€¦by including only files (where file misleadingly means actual file _or_
                // directory)â€¦
                .filter((item) => item.kind === 'file')
                // â€¦and, depending on previous feature detectionâ€¦
                .map((item) =>
                supportsFileSystemAccessAPI
                    // â€¦either get a modern `FileSystemHandle`â€¦
                    ? item.getAsFileSystemHandle()
                    // â€¦or a classic `File`.
                    : item.getAsDataURL(),
                );
                // Loop over the array of promises.
                for await (const handle of fileHandlesPromises) {
                    // This is where we can actually exclusively act on the files.
                    if (handle.kind === 'file' || handle.isFile) {
                      console.log(`File: ${handle.name}`);
                      const filename = handle.name;
                      const file = await handle.getFile();
                      if (filename.toLowerCase().includes('.cas'))
                      {
                        ndata = cas2tap(new Uint8Array(await file.arrayBuffer()))
                        tape_load(ndata, ndata.length, filename);
                      }
                      else
                      {
                        const data = await file.text();
                        const length = data.length;
                        tape_load(data, length, filename);
                      }

                    }
                }
            });
            function cas2tap(data) {
                const adata = data;
                const length = adata.byteLength;
                //console.log(length, adata);
                let ndata = "";
                for (i = 0x10; i < length; i++)
                {
                    for(j = 0; j < 8; j++)
                        if (adata[i]&(0x80>>j))
                            ndata += '1';
                        else
                            ndata += '0';
                }
                return ndata                
            }
            function sleep(ms) {
                const wakeUpTime = Date.now() + ms;
                while (Date.now() < wakeUpTime) {}
            }
            function RESET(force) {
                if (reset_required || force) {
                    tapename = Module.ccall('remote', // name of C function
                    'number', // return type
                    ['number'], // argument types
                    [0]); // arguments
                    reset_required = false;
                }
            };
            function LOAD() {
                var result = Module.ccall('remote', // name of C function
                'number', // return type
                ['number'], // argument types
                [1]); // arguments             
            };
            function RUN() {
                var result = Module.ccall('remote', // name of C function
                'number', // return type
                ['number'], // argument types
                [2]); // arguments  
                reset_required = true;           
            };          
            function tape_prev() {
                var result  = Module.ccall('remote', // name of C function
                'string', // return type
                ['number'], // argument types
                [3]); // arguments  
                tapename = result;
                screen_num = 0;
            }; 
            function tape_next() {
                var result  = Module.ccall('remote', // name of C function
                'string', // return type
                ['number'], // argument types
                [4]); // arguments             
                tapename = result;
                screen_num = 0;
            };                       
            async function tape_load(data, length, filename) {
                <!-- console.log(data, length, filename); -->
                RESET();
                var result  = Module.ccall('remote', // name of C function
                'string', // return type
                ['number', 'number', 'string', 'string'], // argument types
                [6, length, data, filename]); // arguments  
                console.log(result);
                tapename = result;
                screen_num = 0;
            };
            function TURBO_OFF() {
                var result = Module.ccall('remote', // name of C function
                'number', // return type
                ['number','number'], // argument types
                [7,0]); // arguments                  
            } 
            async function upload_file() {
                const curFiles = input.files;
                for (const file of curFiles) {
                    // const file = await handle.getFile();
                    filename = file.name;
                    if (filename.toLowerCase().includes('.cas'))
                    {
                      const adata = new Uint8Array(await file.arrayBuffer());
                      const length = adata.byteLength;
                      console.log(length, adata);
                      let ndata = "";
                      for (i = 0x10; i < length; i++)
                      {
                          for(j = 0; j < 8; j++)
                              if (adata[i]&(0x80>>j))
                                  ndata += '1';
                              else
                                  ndata += '0';
                      }
                      tape_load(ndata, ndata.length, filename);
                    }
                    else
                    {
                      const data = await file.text();
                      const length = data.length;
                      tape_load(data, length, filename);
                    }
                }                
            }
            // document.addEventListener("paste", (event) => {
            //     event.preventDefault();
            //     let paste = (event.clipboardData || window.clipboardData).getData("text");
            //     console.log(paste)
            //     emulatorTyping(paste, false);
            //     // paste = paste.toUpperCase();
            //     // const selection = window.getSelection();
            //     // if (!selection.rangeCount) return;
            //     // selection.deleteFromDocument();
            //     // selection.getRangeAt(0).insertNode(document.createTextNode(paste));
            //     // selection.collapseToEnd(); 
            // });
            Date.prototype.format = function (f) {
                if (!this.valueOf()) return " ";
                var weekKorName = ["ì¼ìš”ì¼", "ì›”ìš”ì¼", "í™”ìš”ì¼", "ìˆ˜ìš”ì¼", "ëª©ìš”ì¼", "ê¸ˆìš”ì¼", "í† ìš”ì¼"];
                var weekKorShortName = ["ì¼", "ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† "];
                var weekEngName = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                var weekEngShortName = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
                var d = this;
                return f.replace(/(yyyy|yy|MM|dd|KS|KL|ES|EL|HH|hh|mm|ss|a\/p)/gi, function ($1) {
                    switch ($1) {
                        case "yyyy": return d.getFullYear(); // ë…„ (4ìë¦¬)
                        case "yy": return (d.getFullYear() % 1000).zf(2); // ë…„ (2ìë¦¬)            
                        case "MM": return (d.getMonth() + 1).zf(2); // ì›” (2ìë¦¬)
                        case "dd": return d.getDate().zf(2); // ì¼ (2ìë¦¬)
                        case "KS": return weekKorShortName[d.getDay()]; // ìš”ì¼ (ì§§ì€ í•œê¸€)
                        case "KL": return weekKorName[d.getDay()]; // ìš”ì¼ (ê¸´ í•œê¸€)
                        case "ES": return weekEngShortName[d.getDay()]; // ìš”ì¼ (ì§§ì€ ì˜ì–´)
                        case "EL": return weekEngName[d.getDay()]; // ìš”ì¼ (ê¸´ ì˜ì–´)
                        case "HH": return d.getHours().zf(2); // ì‹œê°„ (24ì‹œê°„ ê¸°ì¤€, 2ìë¦¬)
                        case "hh": return ((h = d.getHours() % 12) ? h : 12).zf(2); // ì‹œê°„ (12ì‹œê°„ ê¸°ì¤€, 2ìë¦¬)
                        case "mm": return d.getMinutes().zf(2); // ë¶„ (2ìë¦¬)
                        case "ss": return d.getSeconds().zf(2); // ì´ˆ (2ìë¦¬)
                        case "a/p": return d.getHours() < 12 ? "ì˜¤ì „" : "ì˜¤í›„"; // ì˜¤ì „/ì˜¤í›„ êµ¬ë¶„
                        default: return $1;
                    }
                });
            };
            String.prototype.string = function (len) { var s = '', i = 0; while (i++ < len) { s += this; } return s; };
            String.prototype.zf = function (len) { return "0".string(len - this.length) + this; };
            Number.prototype.zf = function (len) { return this.toString().zf(len); };  

            const kcanvas = document.getElementById('keyboardCanvas');
            const ctx = kcanvas.getContext('2d');

            var show_keyboard = false;
            function toggle_keyboard() {
                show_keyboard = true;
                if (kcanvas.style.display =='none') {
                    kcanvas.style.display = 'block'
                    document.getElementById('showkeyboard').value = 'ê°€ìƒí‚¤ë³´ë“œ ë‹«ê¸°';    
                }
                else
                {
                    kcanvas.style.display = 'none'
                    document.getElementById('showkeyboard').value = 'ê°€ìƒí‚¤ë³´ë“œ';    
                }
            }
            function hasTouchSupport() {
                return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            }
            if (!hasTouchSupport() && !show_keyboard) {
                kcanvas.style.display = 'none';
                document.getElementById('showkeyboard').style.display = 'block';
            }
        
            kcanvas.width = window.innerWidth
            kcanvas.height = window.innerHeight / 2;
        
            const normalKeys = [
                ['F1', 'F2', 'F3', 'F4', 'F5', ' ', 'HOME', 'â†', 'â†’', 'â†‘', 'â†“'],
                ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '^', '\\', 'BREAK'],
                ['ESC', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '@', '[',  'DEL', 'GRP'],
                ['CTRL', 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ';', ":", ']', 'RETURN'],
                ['SHIFT', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/', 'SHIFT'],
                ['LOCK', 'SPACE']
            ];
        
            const shiftKeys = [
                ['F1', 'F2', 'F3', 'F4', 'F5', ' ', 'CLS', 'â†', 'â†’', 'â†‘', 'â†“'],
                ['!', '"', '#', '$', '%', '&', "'", '(', ')', '0', '=', '~', '\\', 'BREAK'],
                ['ESC', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '@', '{', 'INS', 'GRP'],
                ['CTRL', 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', '+', '*', '}', 'RETURN'],
                ['SHIFT', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<', '>', '?', 'SHIFT'],
                ['LOCK', 'SPACE']
            ];

            let nkeys = [].concat(...normalKeys);
            let skeys = [].concat(...shiftKeys);
            
            const offsets = [40,40,0,0,0,90]
        
            let keyWidth, keyHeight;
            let isShiftToggled = false;
            let isLockToggled = false;
            let isGRPToggled = false;
            let isCtrlToggled = false;
            let pressedKey = null;
            const specialKeys = ['F1', 'F2', 'F3', 'F4', 'F5', 'â†', 'â†’', 'â†‘', 'â†“', 'HOME','ESC', 'CLS', 'TAB', 'CTRL', 'LOCK', 'BREAK', 'INS', 'DEL', 'RETURN', 'GRP', 'SHIFT'];
        
            const keyClickSound = new Audio('typing.wav'); // í‚¤ í´ë¦­ ì‚¬ìš´ë“œ íŒŒì¼ ê²½ë¡œë¥¼ ì§€ì •í•˜ì„¸ìš”
        
            function calculateKeySize() {
                keyWidth = (kcanvas.width) / 15;
                keyHeight = kcanvas.height / 6;
            }
        
            function drawKey(x, y, width, height, key, isToggled = false) {
                const radius = 10;
        
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
        
                if (specialKeys.includes(key)) {
                    ctx.fillStyle = isToggled ? '#505050' : '#404040';
                } else {
                    ctx.fillStyle = (key === pressedKey ? '#b0b0b0' : '#f0f0f0');
                }
                ctx.fill();
                ctx.strokeStyle = '#999';
                ctx.stroke();
        
                ctx.fillStyle = specialKeys.includes(key) ? '#ffffff' : '#333333';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(key, x + width / 2, y + height / 2, width * 0.8);
            }
        
            function drawKeyboard() {
                ctx.clearRect(0, 0, kcanvas.width, kcanvas.height);
                
                const keys = isShiftToggled ? shiftKeys : normalKeys;
                
                keys.forEach((row, rowIndex) => {
                    let xOffset = offsets[rowIndex];
                    row.forEach((key, keyIndex) => {
                        let width = keyWidth;
                        let height = keyHeight;
                        
                        if (key === 'SPACE') width = keyWidth * 10;
                        else if (['F1','F2', 'F3', 'F4', 'F5', 'CTRL', 'TAB', 'LOCK', 'RETURN'].includes(key)) width = keyWidth * 1.5;
                        else if (key == 'SHIFT') width = keyWidth * 2;
                        
                        if (key != ' ')
                            drawKey(xOffset, rowIndex * keyHeight, width, height, key, (key === 'SHIFT' && isShiftToggled) || (key === 'LOCK' && isLockToggled) || (key == 'CTRL' && isCtrlToggled) || (key == 'GRP' && isGRPToggled));
                        xOffset += width;
                    });
                });
            }
        
            function handleTouch(e) {
                e.preventDefault();
                const rect = kcanvas.getBoundingClientRect();
                const x = e.touches ? e.touches[0].clientX - rect.left : e.clientX - rect.left;
                const y = e.touches ? e.touches[0].clientY - rect.top : e.clientY - rect.top;
                
                const keys = isShiftToggled ? shiftKeys : normalKeys;
                
                let yOffset = 0;
                for (let rowIndex = 0; rowIndex < keys.length; rowIndex++) {
                    let xOffset = offsets[rowIndex];
                    for (let keyIndex = 0; keyIndex < keys[rowIndex].length; keyIndex++) {
                        const key = normalKeys[rowIndex][keyIndex];
                        let width = keyWidth;
                        let height = keyHeight;
                        
                        if (key === 'SPACE') width = keyWidth * 10;
                        else if (['F1','F2', 'F3', 'F4', 'F5', 'TAB', 'LOCK', 'RETURN'].includes(key)) width = keyWidth * 1.5;
                        else if (key == 'CTRL') width = keyWidth * 1.7;
                        else if (key == 'SHIFT') width = keyWidth * 2;
                        
                        if (x >= xOffset && x < xOffset + width &&
                            y >= yOffset && y < yOffset + height) {
                            //console.log('Pressed key:', key);
                            pressedKey = key;
                            keyClickSound.play();
                            drawKeyboard();
                            
                            if (key === 'SHIFT') {
                                isShiftToggled = !isShiftToggled;
                            } else if (key === 'CTRL') {
                                isCtrlToggled = !isCtrlToggled;
                            } else if (key === 'GRP') {
                                isGRPToggled = !isGRPToggled;
                            } else {
                                // ì—¬ê¸°ì—ì„œ í‚¤ ì…ë ¥ì„ ì—ë®¬ë ˆì´í„°ë¡œ ì „ë‹¬
                                emulatorKeyPress(key);
                                // SHIFT, GRP, CTRL í‚¤ê°€ í† ê¸€ëœ ìƒíƒœì—ì„œ ë‹¤ë¥¸ í‚¤ë¥¼ ëˆ„ë¥´ë©´ ìƒíƒœ í•´ì œ
                                if (!isLockToggled)
                                {
                                    isShiftToggled = false;
                                    isGRPToggled = false;
                                    isCtrlToggled = false;
                                }
                            }
                            setTimeout(() => {
                                if (!pressedKey)
                                    handleReleseTouch();
                            }, 1000);
                            return;
                        }
                        xOffset += width;
                    }
                    yOffset += keyHeight;
                }
            }
        
            kcanvas.addEventListener('touchstart', handleTouch);
            kcanvas.addEventListener('touchend', handleReleseTouch);
            kcanvas.addEventListener('mousedown', function(e) {
                // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ë¥¼ í„°ì¹˜ ì´ë²¤íŠ¸ë¡œ ë³€í™˜
                const touch = {
                    clientX: e.clientX,
                    clientY: e.clientY
                };
                handleTouch({touches: [touch], preventDefault: function() {}});
            });
            kcanvas.addEventListener('mouseup', handleReleseTouch);

            function handleReleseTouch() {
                pressedkey = null;
                emulatorKeyPress(pressedkey);
                setTimeout(() => {
                    pressedKey = null;
                    drawKeyboard();
                }, 100);
            }
            
            function resizeCanvas() {
                kcanvas.width = window.innerWidth * 0.96;
                kcanvas.height = window.innerHeight / 4;
                calculateKeySize();
                drawKeyboard();
            }
        
            // ì´ˆê¸° í‚¤ë³´ë“œ ê·¸ë¦¬ê¸° ë° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ ì„¤ì •
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        
            // ì—ë®¬ë ˆì´í„°ë¡œ í‚¤ ì…ë ¥ì„ ì „ë‹¬í•˜ëŠ” í•¨ìˆ˜ (êµ¬í˜„ í•„ìš”)
            function emulatorKeyPress(key, shift) {
                // SPC1000 ì—ë®¬ë ˆì´í„°ë¡œ í‚¤ ì…ë ¥ì„ ì „ë‹¬í•˜ëŠ” ë¡œì§
                // console.log('Emulator key press:', key, isShiftToggled, isCtrlToggled, isGRPToggled, isLockToggled);
                Module.ccall('keydown', 'null', ['string','boolean', 'boolean', 'boolean','boolean','boolean'], [key, shift != null ? shift : isShiftToggled, isCtrlToggled, isGRPToggled, isLockToggled, shift != null]);
            }
            function emulatorTyping(cmd, turbooff=true) {
                let ms = 0;
                if (turbooff)
                    TURBO_OFF();
                emulatorKeyPress(null);
                cmd.split('').forEach((c) => {
                    let uppercase = false;
                    if (c == ' ')
                        c = 'SPACE'
                    else if (c == '\n')
                        c = 'RETURN'
                    if (c >= 'a' && c <= 'z') {
                        c = c.toUpperCase()
                    } else if (c >= 'A' && c <= 'Z') 
                        uppercase = true;
                    if (!uppercase && nkeys.indexOf(c)>=0) {
                        setTimeout(() => emulatorKeyPress(c, false), ms += 50);
                    } else if (skeys.indexOf(c)>=0) {
                        c = nkeys[skeys.indexOf(c)]
                        setTimeout(() => emulatorKeyPress(c, true), ms += 50);
                    } else {
                        console.log('error:',c)
                    }
                });
            }
            function GetURLParameter(sParam)
            {
                var sPageURL = window.location.search.substring(1);
                var sURLVariables = sPageURL.split('&');
                for (var i = 0; i < sURLVariables.length; i++) 
                {
                    var sParameterName = sURLVariables[i].split('=');
                    if (sParameterName[0] == sParam) 
                    {
                        return sParameterName[1];
                    }
                }
            }
            function isHex(h) {
                var a = parseInt(h,16);
                return (a.toString(16) ===h.toLowerCase())
            }
            Module['onRuntimeInitialized'] = prepare_tape_loading;
            var first_initialized = true
            var prev_tape = null;
            function prepare_tape_loading()
            {
                const tape = GetURLParameter('tape');
                const load = GetURLParameter('load');
                const exec = GetURLParameter('exec');
                if (first_initialized) {
                    first_initialized = false
                    tape_loading(tape, load, exec)
                }
            }
            function tape_loading(tape, load, exec) {
                if (tape != prev_tape) {
                    var req = new XMLHttpRequest();
                    var cas = tape.toLowerCase().includes('.cas')
                    req.onload = function(){
                        var data = cas ? new Uint8Array(this.response) : this.responseText;
                        if (this.status == 404) {
                            console.log('404 error')
                            return;
                        }
                        title = decodeURIComponent(tape)
                        let ms = data.length/150
                        console.log(data.length, tape, ms)
                        if (cas)
                            data = cas2tap(data)
                        ms = data.length/150
                        console.log(data.length, tape, ms)
                        setTimeout(() => tape_load(data, data.length, title), ms);
                        setTimeout(() => LOAD(), ms += 2000);
                        if (load) {
                            load.split(';').forEach((cmd) => {
                                if (cmd == 'F6')
                                    setTimeout(() => LOAD(), ms += 2000);
                            });
                        }
                        console.log(exec, ms)
                        if (exec == null || exec.toUpperCase() == 'RUN')
                        {
                            setTimeout(() => RUN(), ms + 5000);
                            return;
                        } else if (exec == '')
                            return;
                        else if (isHex(exec)) 
                            cmd = `call&h${exec}`;
                        else
                            cmd = exec;
                        setTimeout(() => emulatorTyping(cmd+'\n'), ms += 2000);
                    };
                    req.open('GET', `./taps/${tape}`);
                    if (cas)
                        req.responseType = "arraybuffer";
                    req.send(); 
                    prev_tape = tape;               
                }
            }
        </script>
        <script src="index.js"></script>
    </body>
</html>
